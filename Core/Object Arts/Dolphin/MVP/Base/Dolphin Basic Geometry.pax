| package |
package := Package name: 'Dolphin Basic Geometry'.
package paxVersion: 2;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Basic Geometry.
Copyright (c) Object Arts Ltd. 1997-2018. Portions Copyright (c) CGI Group (Europe) Ltd. 1997.
'.


package setClassNames: #(
	#{ExternalPoint}
	#{ExternalRectangle}
	#{Point}
	#{Point3D}
	#{POINTL}
	#{RECT}
	#{Rectangle}
).

package setMethodNames: #(
	#(#{ArithmeticValue} #_expandRectangle:)
	#(#{ArithmeticValue} #_insetRectangle:)
	#(#{ArithmeticValue} #_offsetRectangle:)
	#(#{DWORD class} #fromPoint:)
	#(#{Number} #@)
	#(#{Number} #asPoint)
	#(#{Number} #asPoint3D)
	#(#{UserLibrary} #subtractRect:lprcSrc1:lprcSrc2:)
).

package setVariableNames: #(
	#{POINT}
	#{RECTL}
).

package setAliasVariableNames: #(
	#{POINT}
	#{RECTL}
).

package setPrerequisites: #(
	'..\..\Base\Dolphin'
).

package!

"Class Definitions"!

Object subclass: #Rectangle
	instanceVariableNames: 'origin corner'
	classVariableNames: 'Empty'
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {}!
ExternalStructure subclass: #ExternalPoint
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {}!
ExternalStructure subclass: #ExternalRectangle
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {}!
ExternalPoint subclass: #POINTL
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_x' -> 16r0.
		'_OffsetOf_y' -> 16r4
	}!
ExternalRectangle subclass: #RECT
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_bottom' -> 16rC.
		'_OffsetOf_left' -> 16r0.
		'_OffsetOf_right' -> 16r8.
		'_OffsetOf_top' -> 16r4
	}!
ArithmeticValue subclass: #Point
	instanceVariableNames: 'x y'
	classVariableNames: 'Zero'
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {}!
ArithmeticValue subclass: #Point3D
	instanceVariableNames: 'x y z'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''
	classConstants: {}!

"Variable Aliases"!

POINT := POINTL!

RECTL := RECT!


"Loose Methods"!

!ArithmeticValue methodsFor!

_expandRectangle: rect
	"Private - Expand the <Rectangle>, rect, by the magnitude of the receiver.
	 All sides of the rectangle are expanded by the specified amount.
	Double-dispatched from the Rectangle itself."

	^rect species
		origin: (rect origin - self)
		corner: (rect corner + self)!

_insetRectangle: aRectangle 
	"Private - Inset the <Rectangle> argument by the magnitude of the receiver. All sides of the
	rectangle are inset by the specified amount. Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin + self corner: aRectangle corner - self!

_offsetRectangle: aRectangle 
	"Private - Offset the <Rectangle> argument by the magnitude of the receiver.
	Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin + self corner: aRectangle corner + self! !
!ArithmeticValue categoriesFor: #_expandRectangle:!double dispatch!private! !
!ArithmeticValue categoriesFor: #_insetRectangle:!double dispatch!private! !
!ArithmeticValue categoriesFor: #_offsetRectangle:!double dispatch!private! !

!DWORD class methodsFor!

fromPoint: aPoint
	"Private - Answer a new instance of the receiver with high and low
	words set from aPoint assuming its co-ordinates to be 16-bit signed
	integer values, with X in the low-word. This instantiator is somewhat
	similar to the Windows MAKEPOINT macro."

	^(self new)
		lowSWord: aPoint x;
		highSWord: aPoint y;
		yourself! !
!DWORD class categoriesFor: #fromPoint:!instance creation!private! !

!Number methodsFor!

@ yCoord 
	"Answer a Point with the receiver as X and the argument as Y.
	The traditional Make Point primitive is present because this operation may be
	performed a few thousand times when opening a complex window (for example).
	The primitive is simply a VM level implementation of #x:y:, and does not fail."

	^Point x: self y: yCoord!

asPoint
	"Answer a Point with the receiver as both co-ordinates."

	^self @ self!

asPoint3D
	"Answer a Point with the receiver as all three co-ordinates."

	^self @ self @ self! !
!Number categoriesFor: #@!converting!public! !
!Number categoriesFor: #asPoint!converting!public! !
!Number categoriesFor: #asPoint3D!converting!public! !

!UserLibrary methodsFor!

subtractRect: lprcDst lprcSrc1: lprcSrc1 lprcSrc2: lprcSrc2
	<stdcall: bool SubtractRect RECT* RECT* RECT*>
	^self invalidCall: _failureCode! !
!UserLibrary categoriesFor: #subtractRect:lprcSrc1:lprcSrc2:!public!rectangle functions! !

"End of package definition"!

